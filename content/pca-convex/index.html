<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
     <link rel="stylesheet" href="/libs/katex/katex.min.css">
     
    
    <link rel="stylesheet" href="/css/franklin.css">
    <link rel="stylesheet" href="/css/basic.css">
    <link rel="icon" href="/assets/favicon.png">
     <title>PCA as a convex optimization problem</title>  
</head>
<body>
    <header>
<div class="blog-name"><a href="/">Longest Path Search</a></div>
<nav>
  <ul>
    <li><a href="https://angeris.github.io">About</a></li>
    <li><a href="https://github.com/angeris">Code</a></li>
    <li><a href="/feed.xml">RSS feed</a></li>
    <li><a href="https://c.xkcd.com/random/comic/">Fun</a></li>
  </ul>
</nav>
</header>

    
    
    <div class="franklin-content">
        <h1>PCA as a convex optimization problem</h1>
        <p>Posted <strong>2018-05-16</strong></p>
    </div>
    
    <!-- Content appended here -->
    
<div class="franklin-content">
<p>It&#39;s been a while since I last posted &#40;my posting has been less once every two weeks and more like once every two months&#41;, but here&#39;s a post I&#39;ve been sitting on for a while that I never got around to finishing. As per <a href="https://rachelbythebay.com/w/2018/03/13/write/">rachelbythebay&#39;s advice</a>, I decided to just finish it and post it up. It&#39;s likely to be a little rough, but feel free to <a href="https://twitter.com/GuilleAngeris">tweet</a> any questions or things that you&#39;d like more fleshed out &#40;as usual&#33;&#41;.</p>
<h2 id="quick_introduction_to_pca"><a href="#quick_introduction_to_pca" class="header-anchor">Quick introduction to PCA</a></h2>
<p>Most people know <a href="https://en.wikipedia.org/wiki/Principal_component_analysis">Principal Component Analysis</a> &#40;PCA&#41; as a fast, and easily-scalable dimensionality-reduction technique used quite frequently in machine learning and data exploration—in fact, it&#39;s often mentioned that one-layer, linear neural network<sup id="fnref:losstype"><a href="#fndef:losstype" class="fnref">[1]</a></sup> applied on some data-set recovers the result from PCA.</p>
<p>It&#39;s &#40;also&#41; often mentioned that PCA is one of the <a href="https://groups.google.com/forum/#&#33;topic/10725-f12/P9e8BsqaAok">few non-convex problems that we can solve efficiently</a>, though a &#40;let&#39;s say &#39;non-constructive&#39;&#41; answer showing this problem is convex is given in <a href="https://stats.stackexchange.com/questions/301532/is-pca-optimization-convex">this Stats.SE thread</a>, which requires knowing the eigenvectors of \(X^TX\), a priori. It turns out it&#39;s possible to create a fairly natural semi-definite program which actually constructs the solution in its entirety.</p>
<p>Since I&#39;ll only give a short overview of the topic of PCA itself, I won&#39;t go too much into depth on methods of solving this. But, the general idea of PCA is to find the best low-rank approximation of a given matrix \(A\). In other words, we want, for some given \(k\):</p>
\[
\begin{aligned}
& \underset{X}{\text{minimize}}
& & \| A - X \|_F^2  \\
& \text{subject to}
& & \text{rank}(X) = k,
\end{aligned}
\]
<p>where \(\| B \|_F^2\) is the square of the Frobenius norm of \(B\) &#40;i.e. it is the sum of the squares of each entry of \(B\)&#41;. Why is this useful? Well, in the general formulation, we can write the SVD decomposition of some optimal \(X^* \in \mathbb{R}^{m\times n}\),</p>
\[
X^* = U^*\Sigma^* (V^*)^T
\]
<p>with orthogonal \(U^* \in \mathbb{R}^{m\times k}, V^*\in \mathbb{R}^{n\times k}\) and diagonal \(\Sigma^* \in \mathbb{R}^{k\times k}\). Then the columns of \(V^*\) represent the \(k\) most important features of \(A\) &#40;assuming that each row of \(A\) is a point of the dataset&#41;. This may seem slightly redundant if you already know the punchline, but we&#39;ll get there in a second. </p>
<p>For now, define the SVD of \(A\) in a similar way to the above</p>
\[
A = U\Sigma V^T.
\]
<p>with orthogonal \(U, V\) and diagonal \(\Sigma\).</p>
<p>For convenience, it&#39;s easiest to define the diagonal of \(\Sigma\) &#40;the singular values of \(A\)&#41; to be sorted with the top-left value being the largest and bottom-right value being the smallest. Then let \(U_k\) be the matrix which contains only the first \(k\) columns of \(U\) &#40;and similarly for \(V_k\)&#41;, while \(\Sigma_k\) is the \(k\) by \(k\)  diagonal sub-matrix of \(\Sigma\) containing only the first \(k\) values of the diagonal &#40;as usual, starting from the top left&#41;.</p>
<p>Now we can get to the punchline I was talking about earlier: it turns out that the SVD of \(X^*\) is the <em>truncated</em> SVD of \(A\), in other words, if the SVD of \(A\) is \(U\Sigma V^T\), then the optimal solution is</p>
\[
X^* = U_k\Sigma_kV_k^T.
\]
<p>This is the usual way of computing the PCA decomposition of \(A\): simply take the SVD and then look at the first \(k\) columns of \(V\).<sup id="fnref:truncatedsvd"><a href="#fndef:truncatedsvd" class="fnref">[2]</a></sup> We&#39;ll make use of this fact to show that the optimal values are equal, but it won&#39;t be necessary to actually <em>compute</em> the result.</p>
<h2 id="construction_of_the_sdp"><a href="#construction_of_the_sdp" class="header-anchor">Construction of the SDP</a></h2>
<p>In general, semi-definite programs &#40;i.e. optimization over symmetric, positive-semidefinite matrices with convex objectives and constraints&#41; are convex problems. Here, we&#39;ll construct a &#40;relatively&#41; simple reduction of the non-convex problem of PCA, as presented above, to the SDP.</p>
<h3 id="quick_overview_of_method"><a href="#quick_overview_of_method" class="header-anchor">Quick overview of method</a></h3>
<p>This entire idea was interesting to me, since it was mentioned in <a href="http://www.stat.cmu.edu/~ryantibs/convexopt-S15/scribes/26-nonconvex-scribed.pdf">this lecture</a> which was a result I didn&#39;t know about. There aren&#39;t any complete proofs of this online, other than a quick mention in <a href="https://papers.nips.cc/paper/5136-fantope-projection-and-selection-a-near-optimal-convex-relaxation-of-sparse-pca">Vu, et al. &#40;2013&#41;</a>, though it&#39;s not hard to show the final result given the general ideas. I highly encourage you to try the proof out after reading only the main ideas, if you&#39;re interested&#33;</p>
<p>First, we&#39;ll start with the usual program, call it <em>program Y</em>:</p>
\[
\begin{aligned}
& \underset{X}{\text{minimize}}
& & \| A - X \|_F^2  \\
& \text{subject to}
& & \text{rank}(X) = k,
\end{aligned}
\]
<p>and construct the equivalent program &#40;this step can be skipped with a cute trick below&#41;, with \(F = A^TA\),</p>
\[
\begin{aligned}
& \underset{P}{\text{minimize}}
& & \| F - P \|_F^2  \\
& \text{subject to}
& & \text{rank}(P) = k,\\
&&& P^2 = P,\\
&&& P^T = P,
\end{aligned}
\]
<p>in other words, this is a program over projection matrices \(P\). This can then be put into the form</p>
\[
\begin{aligned}
& \underset{P}{\text{maximize}}
& & \text{tr}(FP)  \\
& \text{subject to}
& & \text{rank}(P) = k,\\
&&& P^2 = P,\\
&&& P^T = P.
\end{aligned}
\]
<p>for some matrix \(F\), and it can be relaxed into the following SDP, let&#39;s call it <em>problem Z</em>,</p>
\[
\begin{aligned}
& \underset{P}{\text{maximize}}
& & \text{tr}(FP)  \\
& \text{subject to}
& & \text{tr}(P) = k,\\
&&& 0\preceq P \preceq I,
\end{aligned}
\]
<p>where \(A \preceq B\) is an inequality with respect to the semi-definite cone &#40;i.e. \(A \preceq B \iff B - A\) is positive semi-definite&#41;. You can then show that this SDP has <em>zero integrality gap</em> with the above program over the projection matrices. More specifically, any solution to the relaxation can be easily turned into a solution of the original program.</p>
<p>Just a random side-note: if you took or followed Stanford&#39;s EE364A course for the previous quarter &#40;Winter 2018&#41;, the latter part of this proof idea may seem familiar—it was a problem written for the final exam. My original intent with it was to guide the students through the complete proof, but better judgement prevailed and the question was cut down to only that last part with some hints.</p>
<h2 id="complete_if_somewhat_short_steps"><a href="#complete_if_somewhat_short_steps" class="header-anchor">Complete &#40;if somewhat short&#33;&#41; steps</a></h2>
<p>The two interesting points of the whole proof are &#40;a&#41; to realize that any solution of the original problem &#40;program Y&#41; can be written as a solution \(X = AP'\) for some projection matrix \(P'\) &#40;which, of course, will turn out to be the projection matrix \(P\) which solves program Z, namely \(P' = V_kV_k^T\)&#41;, and &#40;b&#41; to note that we can prove that program Z has zero integrality gap since, if we have a solution to the SDP given by \(P^* = UDU^T\), then we can &#39;fix&#39; non-integral eigenvalues via solving the problem</p>
\[
\begin{aligned}
& \underset{x}{\text{maximize}}
& & c^Tx  \\
& \text{subject to}
& & 1^Tx = k,\\
&&& 0\le x_i \le 1, ~~\forall i,
\end{aligned}
\]
<p>where \(c_i = (U^TAU)_{ii}\). This LP has an integral solution \(x^*\) &#40;what should this solution be?&#41; which preserves the objective value of the original problem, so \(\bar P^* = U\text{diag}(x^*)U^T\) is a feasible, integral solution to the original problem, with the same objective value as the previous so the SDP relaxation is tight&#33;</p>
<p>Using all of this, then we&#39;ve converted the PCA problem into a purely convex one, without computing the actual solution beforehand.</p>
<p><table class="fndef" id="fndef:losstype">
    <tr>
        <td class="fndef-backref"><a href="#fnref:losstype">[1]</a></td>
        <td class="fndef-content">More specifically, a one-layer, linear NN with \(\ell_2\) loss.</td>
    </tr>
</table>
 <table class="fndef" id="fndef:truncatedsvd">
    <tr>
        <td class="fndef-backref"><a href="#fnref:truncatedsvd">[2]</a></td>
        <td class="fndef-content">As usual, there are smarter ways of doing this. It turns out one can run a truncated or partial SVD decomposition, which doesn&#39;t require constructing all singular values and all the columns of \(U, V\). This is far more efficient whenever \(k\ll \min\{m, n\}\), where \(m,n\) are the dimensions of the data. This latter condition is usually the case for practical purposes.</td>
    </tr>
</table>
</p>
<div class="page-foot">
    Built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and <a href="https://julialang.org">Julia</a>.
</div>
</div><!-- CONTENT ENDS HERE -->
    
        <script src="/libs/katex/katex.min.js"></script>
<script src="/libs/katex/auto-render.min.js"></script>
<script>renderMathInElement(document.body)</script>

    
    
  </body>
</html>
