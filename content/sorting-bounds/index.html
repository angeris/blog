<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
     <link rel="stylesheet" href="/libs/katex/katex.min.css">
     
    
    <link rel="stylesheet" href="/css/franklin.css">
    <link rel="stylesheet" href="/css/basic.css">
    <link rel="icon" href="/assets/favicon.png">
     <title>Comparisons and information theory: why the worst-case complexity of sorting is n log n</title>  
</head>
<body>
    <header>
<div class="blog-name"><a href="/">Longest Path Search</a></div>
<nav>
  <ul>
    <li><a href="https://angeris.github.io">About</a></li>
    <li><a href="https://github.com/angeris">Code</a></li>
    <li><a href="/feed.xml">RSS feed</a></li>
    <li><a href="https://c.xkcd.com/random/comic/">Fun</a></li>
  </ul>
</nav>
</header>

    
    
    <div class="franklin-content">
        <h1>Comparisons and information theory: why the worst-case complexity of sorting is n log n</h1>
        <p>Posted <strong>2020-06-19</strong></p>
    </div>
    
    <!-- Content appended here -->
    
<div class="franklin-content">
<p>In this post, we&#39;ll talk a bit about the usual proofs about the worst-case query complexity of sorting &#40;at least, in the deterministic case&#41; and then use a beautiful &#40;and surprisingly simple&#33;&#41; tool from computational lower bounds to give a very general argument about the construction </p>
<h2 id="the_usual_approach"><a href="#the_usual_approach" class="header-anchor">The usual approach</a></h2>
<p>There are many notes and posts talking about the fact that sorting will, in the worst case, always take \(\Omega(n \log n)\) comparisons; equivalently, in the worst case, the number of comparisons is about a constant factor away from \(n \log n\) when \(n\) is large. In many cases, the proof presented depends on the fact that the sorting algorithm is deterministic and goes a little like this &#40;see <a href="https://www.bowdoin.edu/~ltoma/teaching/cs231/fall07/Lectures/sortLB.pdf">here</a> for a common case&#41;:</p>
<h3 id="preliminaries"><a href="#preliminaries" class="header-anchor">Preliminaries</a></h3>
<p>Let \(C_k\) be the \(k\)th step of a deterministic sorting algorithm &#40;this can be represented, for example, as a tuple containing what the next comparison should be&#41; with input \(L \in K^n\) where \(L\) is a list of \(n\) comparable elements. &#40;For example, \(L\) can be a list of real numbers, in which case \(K = \mathbb{R}\).&#41;</p>
<p>By the definition of a deterministic algorithm, \(C_k\) depends only on the past \(k-1\) comparisons; <em>i.e.</em>, \(C_k(C_{k-1}, C_{k-2}, \dots, C_1)\). &#40;I am slightly overloading notation here, of course, but the meaning should be clear.&#41; This means that we can view the behavior of the algorithm as a tree, where \(C_k\) is a child node of \(C_{k-1}\) which itself is a child node of \(C_{k-2}\), etc. Additionally, the tree is <em>binary</em> since the output of a comparison is only one of two possibilities &#40;if \(C_k = (a, b)\), then either \(a\le b\) or \(b \le a\)&#41;.</p>

<img src="/content/images/sorting-bounds/comparison_tree.png" class="insert" style="width: 80%">

<p>Finally, let the leaf nodes of this tree be the list of indices &#40;say, \(p\), where each entry is an index, \(p_i \in \{1, \dots, n\}\) for \(i=1, \dots, n\)&#41; such that the list permuted at these indices is sorted, \(L_{p_1} \le L_{p_2} \le \dots, \le L_{p_n}\). Note that the number of nodes needed to get from the root node to a given leaf node &#40;or permutation&#41; is exactly the number of comparisons that the algorithm makes before it returns a specific permutation. If we can show that the height &#40;the length of the longest path from root to leaf&#41; of the tree is always larger than about \(n \log n\), then we&#39;ve shown that this algorithm must take at least \(n \log n\) steps.</p>
<h3 id="bound_on_the_height"><a href="#bound_on_the_height" class="header-anchor">Bound on the height</a></h3>
<p>The idea for the bound is pretty simple: since this algorithm is a sorting algorithm and it can receive <em>any</em> unsorted list, then each of the \(n!\) possible permutations must be a leaf node of the tree. &#40;Why?&#41; Additionally, the maximum number of leaves for a binary tree of height \(h\) is \(2^h\), which, in turn, implies that we must have \(2^h \ge n!\). Taking the log of both sides shows that:</p>
\[
h = \log(2^h) \ge \log(n!) = \Omega(n\log n),
\]
<p>which is exactly what we wanted to show. &#40;The second equality is shown, for example, in the <a href="https://www.bowdoin.edu/~ltoma/teaching/cs231/fall07/Lectures/sortLB.pdf">original reference for this proof</a>; see page 2.&#41;</p>
<h3 id="some_takeaways_from_this_proof"><a href="#some_takeaways_from_this_proof" class="header-anchor">Some takeaways from this proof</a></h3>
<p>To prove this statement we only really used a few things: &#40;a&#41; the algorithm has to decide between \(n!\) things, and &#40;b&#41; at each query, it only receives a &quot;yes&quot; or a &quot;no&quot; &#40;as we will soon make rigorous, it only gains 1 bit of information from each query&#41;. The rest of the proof simply sets up scaffolding for the remaining parts, most of which is really somewhat orthogonal to our intuition. The point is: look, we have \(n!\) things we have to decide on and every time we ask a question, we cut down our list of possible true answers by about half. How many times do we need to cut down our list to be able to have exactly one possible answer? &#40;Of course, as we showed before, this should be \(\log_2(n!)\).&#41;</p>
<p>Now, a good number of writings &#40;and some textbooks&#41; I&#39;ve seen simply end here by saying &quot;the algorithm gains at most 1 bit for every query and we need at least \(\log(n!) \sim n \log n\) bits&quot; and then give some vague citation to Shannon&#39;s theorem about communication without explicitly writing out any argument. &#40;While there is some connection, it&#39;s unclear what it is or how to even make it rigorous in a general sense.&#41; It&#39;s a bit of a shame since it doesn&#39;t really take much math to fully justify this intuitive statement, as we will see next.</p>
<h2 id="an_information-theoretic_approach"><a href="#an_information-theoretic_approach" class="header-anchor">An information-theoretic approach</a></h2>
<p>The idea behind a &#40;simple&#41; information theoretic approach is to view the algorithm as attempting to &#39;uncover&#39; the true, sorted permutation by querying an oracle that knows whether two elements are in sorted order or not. Here, the oracle gets to choose some &#39;true&#39; permutation uniformly at random and then the sorting algorithm queries the oracle in a restricted sense: it can only ask yes or no questions about the list.</p>
<p>More formally, we will let \(\mathcal X\) be the set of all \(n!\) possible permutations of \(1\) through \(n\) and let \(X\) the oracle&#39;s permutation such that \(X \sim \mathcal X\) is uniformly randomly sampled from \(\mathcal X\). Then, the algorithm gets to ask a sequence of yes/no queries \(Y_i \in \{0, 1\}\) for \(i=1, \dots, k\) which are dependent on the permutation \(X\), and, at the end of \(k\) queries, must respond with some &#39;guess&#39; for the true permutation \(\hat X\), which is a random variable that depends only on \(Y\).</p>
<p>We can represent the current set up as a Markov chain \(X \to Y \to \hat X\), since \(\hat X\) is conditionally independent of \(X\) given \(Y\) &#40;<em>i.e.</em>, the algorithm can only use information given by \(Y\)&#41; while the random variable \(Y\) depends only on \(X\). The idea then is to give a bound on the number of queries \(k\) required for an algorithm to succeed with probability 1.</p>
<p>To give a lower bound on this quantity, we&#39;ll use a tool from information theory called Fano&#39;s inequality, which, surprisingly, I don&#39;t often see taught in information theory courses. &#40;Perhaps I haven&#39;t been taking the right ones&#33;&#41;</p>
<h3 id="fanos_inequality"><a href="#fanos_inequality" class="header-anchor">Fano&#39;s inequality</a></h3>
<p>I learned about this lovely inequality in John Duchi&#39;s class, EE377: <em>Information Theory and Statistics</em> &#40;the lectures notes for the class are <a href="http://web.stanford.edu/class/stats311/lecture-notes.pdf">here</a>&#41;. Its proof really makes it clear why entropy, as defined by Shannon, is pretty much the exact right quantity to look at. We&#39;ll explore a weaker version of it here that is simpler to prove and requires fewer definitions but which will suffice for our purposes.</p>
<p>We will use \(X, Y\) as random variables and set \(H\) as the entropy, defined:</p>
\[
H(X) = -\sum_{X \in \mathcal{X}}P(X) \log P(X),
\]
<p>where \(\mathcal{X}\) is the space of values that \(X\) can take on. The conditional entropy of \(X\) given \(Y\) is defined as</p>
\[
H(X|Y) = -\sum_{Y \in \mathcal Y} P(Y) \sum_{X \in \mathcal X} P(X\mid Y) \log P(X\mid Y) = H(X, Y) - H(Y).
\]
<p>As usual, the entropy \(H\) is a measure of the &#39;uncertainty&#39; in the variable \(X\), with the maximally uncertain distribution being the uniform one.<sup id="fnref:entropy"><a href="#fndef:entropy" class="fnref">[1]</a></sup> Additionally, note that \(H(X, Y)\) is the entropy taken with respect to the joint distribution of \(X\) and \(Y\). Finally, if \(X\) is a deterministic function of \(Y\), then \(H(X\mid Y) = 0\) which follows from the definition.</p>
<p>For this post, we will only make use of the following three properties of the entropy &#40;I will not prove them here, as there are many available proofs of them, including the notes above and Cover&#39;s famous <em>Elements of Information Theory</em>&#41;:</p>
<ol>
<li><p>The entropy can only decrease when removing variables, \(H(X, Y) \ge H(X)\).</p>
</li>
<li><p>The entropy is smaller than the log of the size of the sample space \(H(X \mid Y) \le H(X) \le \log|\mathcal X|\). &#40;Equivalently, conditioning reduces entropy, and the uniform distribution on \(\mathcal X\) has the highest possible entropy, \(\log|\mathcal X|\).&#41;</p>
</li>
<li><p>If a random variable \(\hat X\) is conditionally independent of \(X\) given \(Y\) &#40;<em>i.e.</em>, if \(X \to Y \to \hat X\) is a Markov chain&#41;, then \(H(X\mid \hat X) \ge H(X\mid Y)\). This is often called a <a href="https://en.wikipedia.org/wiki/Data_processing_inequality">data processing inequality</a>, which simply says that \(X\) has smaller entropy knowing \(Y\) than knowing a variable, \(\hat X\), that has undergone further processing. In other words, you cannot gain more information about \(X\) from a variable \(Y\) by further processing \(Y\).</p>
</li>
</ol>
<p>This is all we need to prove the following inequality. Let \(X \to Y \to \hat X\) be a Markov chain such that \(\hat X\) is conditionally independent of \(X\) given \(Y\) and \(X\) is uniformly drawn from \(\mathcal X\), then the probability that \(X \ne \hat X\) is given by \(P_e\) and \(P_e\) satisfies</p>
\[
P_e \ge 1 - \frac{k+1}{\log |\mathcal X|},
\]
<p>where \(k\) is the number of binary queries made and \(|\mathcal X|\) is the number of elements in \(\mathcal X\).</p>
<h3 id="a_quick_aside"><a href="#a_quick_aside" class="header-anchor">A quick aside</a></h3>
<p>Proving this inequality is enough to show the claim. Note that, we want the probability of error to be 0 &#40;since we want our algorithm to work&#33;&#41; so</p>
\[
1 - \frac{k+1}{\log |\mathcal X|} \le 0 \quad \text{implies} \quad k+1 \ge \log |\mathcal X|,
\]
<p>and, since \(|\mathcal X|\) is the space of possible permutations of size \(n\), &#40;of which there are \(n!\) of&#41; then \(|\mathcal X| = n!\) and \(\log n! \sim \Omega(n \log n)\) then \(k\) must satisfy</p>
\[
k = \Omega(n \log n).
\]
<p>In other words, the number of queries &#40;or comparisons, or whatever&#41; \(k\) must be approximately at least as large as \(n \log n\), asymptotically &#40;up to constant multiples&#41;. In fact, this proves a slightly <em>stronger</em> statement that no probabilistic algorithm can succeed with nonvanishing probability if the number of queries is not on the order of \(n \log n\), which our original proof above does not cover&#33;</p>
<p>Now, the last missing piece is showing that the probability of error is bounded from below.</p>
<h3 id="a_proof_of_fanos_inequality"><a href="#a_proof_of_fanos_inequality" class="header-anchor">A proof of Fano&#39;s inequality</a></h3>
<p>This is a slightly simplified version of the proof presented in <a href="http://web.stanford.edu/class/stats311/lecture-notes.pdf">Duchi&#39;s notes</a> &#40;see section 2.3.2&#41; for the specific case we care about, which requires less additional definitions and supporting statements. Let \(E\) be the &#39;error&#39; random variable that is \(1\) if \(X \ne \hat X\) and 0 otherwise, then let&#39;s look at the quantity \(H(E, X\mid \hat X)\):</p>
\[
H(E, X\mid \hat X) = H(X\mid \hat X, E) + H(E\mid \hat X),
\]
<p>by our definition of conditional entropy, and</p>
\[
H(X\mid \hat X, E) = P_e H(X\mid \hat X, E=1) + (1-P_e)H(X\mid \hat X, E=0),
\]
<p>again by the same definition. Since \(X = \hat X\) whenever there is no error, \(E=0\), then \(H(X\mid \hat X, E=0) = 0\) since \(X\) is known, so, we really have</p>
\[
H(E, X\mid \hat X) = P_e H(X\mid \hat X, E=1) + H(E\mid \hat X).
\]
<p>Since \(E\) can only take on two values, we have that \(H(E\mid \hat X) \le \log(2) = 1\) and we also have that \(H(X\mid \hat X, E=1) \le \log |\mathcal X|\), which gives</p>
\[
H(E, X\mid \hat X) \le P_e \log|\mathcal X| + 1.
\]
<p>Now, we have that</p>
\[
H(E, X\mid \hat X) \ge H(X\mid \hat X) \ge H(X\mid Y).
\]
<p>The first inequality follows from the fact that we&#39;re removing a variable and the second follows from statement 3 in the previous section &#40;as \(X \to Y \to \hat X\)&#41;. Using the definition of \(H(X\mid Y)\), then we have</p>
\[
H(X, Y) - H(Y) \ge H(X) - H(Y) = \log |\mathcal X| - H(Y) \ge \log |\mathcal X| - \log|\mathcal Y|. 
\]
<p>The first inequality here follows since we&#39;re &#40;again&#33;&#41; removing a variable and the equality follows from the fact that \(X\) is uniformly randomly drawn from \(\mathcal X\) and the last inequality follows from the fact that the entropy of \(Y\) is always smaller than that of the uniform distribution on \(\mathcal Y\). Finally, note that, if we have \(k\) queries, then \(|\mathcal Y| = 2^k\) &#40;this is the number of possible values a sequence of \(k\) binary queries can take on&#41;. So, \(\log |\mathcal Y| = k\) &#40;in other words, the maximum amount of information we can get with \(k\) binary queries is \(k\) bits&#41; so we find</p>
\[
\log |\mathcal X| - k \le P_e\log |\mathcal X| + 1,
\]
<p>or, after some slight rewriting:</p>
\[
P_e \ge 1 - \frac{k+1}{\log |\mathcal X|},
\]
<p>as required&#33;</p>
<h3 id="some_discussion"><a href="#some_discussion" class="header-anchor">Some discussion</a></h3>
<p>I think overall that Fano&#39;s inequality is a relatively straightforward way of justifying a ton of the statements one can make about information theory without needing to invoke a large number of more complicated notions. Additionally, the proof is relatively straightforward &#40;in the sense that it only requires very few definitions and properties of the entropy&#41; while also matching our intuition about these problems pretty much exactly.</p>
<p>In particular, we see that sorting is hard not because somehow ordering elements is difficult, but because we have to decide between a bunch of different items &#40;in fact, \(n!\) of them&#41; while only receiving a few bits of information at any point in time&#33; In fact, this bound applies to <em>any</em> yes/no query that one can make of the sorted data, not just comparisons, which is interesting.</p>
<p>There are some even more powerful generalizations of Fano&#39;s inequality which can also be extended to machine learning applications: you can use them to show that, given only some small amount of data, you cannot decide between a parameter that correctly describe the data and one that does not.</p>
<p>This is all to say that, even though entropy is a magical quantity, that doesn&#39;t mean we can&#39;t say very rigorous things about it &#40;and make our intuitions about lower bounds even more rigorous, to boot&#33;&#41;.</p>
<table class="fndef" id="fndef:entropy">
    <tr>
        <td class="fndef-backref"><a href="#fnref:entropy">[1]</a></td>
        <td class="fndef-content">In fact, the entropy is really a measure of how close a variable is to the uniform distribution, in the case of compact domains \(\mathcal X\)—the higher the entropy, the closer it is.</td>
    </tr>
</table>

<div class="page-foot">
    Built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and <a href="https://julialang.org">Julia</a>.
</div>
</div><!-- CONTENT ENDS HERE -->
    
        <script src="/libs/katex/katex.min.js"></script>
<script src="/libs/katex/auto-render.min.js"></script>
<script>renderMathInElement(document.body)</script>

    
    
  </body>
</html>
